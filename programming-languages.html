<h1 id="programming-language-review">Programming Language Review</h1>
<h2 id="ratings-scale">Ratings Scale</h2>
<ul>
<li>3.0: Best of the best, e.g., C for Speed</li>
<li>2.5: Extremely strong</li>
<li>2.0: Good</li>
<li>1.5: Average</li>
<li>1.0: Poor</li>
<li>0.5: Significantly makes the programming language hard to use</li>
<li>0.0: Absolute dealbreaker, the language is unusable IMHO</li>
</ul>
<h2 id="categories">Categories</h2>
<ul>
<li><strong>Speed</strong>: How fast programs written in this language are</li>
<li><strong>Concisenes</strong>: The typical lines of code used to express ideas in this language</li>
<li><strong>Correctness</strong>: How much the language prevents errors or guarantees correctness of programs</li>
<li><strong>Learnability</strong>: How easy it is to learn the language and how likely it is to provide weird 'gotcha' moments</li>
<li><strong>Collaboration</strong>: The tooling to support effortless cross-system builds and the depth of libraries provided</li>
<li><strong>Aesthetics</strong>: How the language looks and feels and the 'coolness' factor</li>
</ul>
<h2 id="java">Java</h2>
<p><strong>Speed</strong>: Java has never been very fast for a compiled language and while Java performs well on many benchmarks, class load times can mean that this is often not what is experienced in practice (2.0)</p>
<p><strong>Conciseness</strong>: Java is the true master of unnecessary boilerplate and while recent versions have started to work against this, many constructs such as lambdas still just take more code than other languages (1.0)</p>
<p><strong>Correctness</strong>: The types and the compile system help a lot here, but Java still allows for many of the worst kind of programming paradigms including null pointers and a dodgy exception system (1.5)</p>
<p><strong>Learnability</strong>: There is a reason why Java was for many years the teaching languages in most universities, it is very easy to learn (2.5)</p>
<p><strong>Collaboration</strong>: Ant, Maven, Gradle and other tools invented and innovated on the nature of collaboration and the wealth of libraries (nearly all of which work on any platform) is the true reason to use Java (3.0)</p>
<p><strong>Aesthetics</strong>: Java is a typical curly-brace language so is mostly quite pleasant, however there is little cool about Java anymore (1.5)</p>
<h2 id="c">C</h2>
<p><strong>Speed</strong>: Few can argue that C isn't the closest to machine code and fastest language there is (3.0)</p>
<p><strong>Conciseness</strong>: Up to a point C is quite concise, but this can quickly disappear when writing complex code (1.5)</p>
<p><strong>Correctness</strong>: Static-typing helps here but C is famous for letting you shoot yourself in the foot (1.5)</p>
<p><strong>Learnability</strong>: C is a very small language, however many of the concepts do trip up learners (2.0)</p>
<p><strong>Collaboration</strong>*: Building cross-platform C is a nightmare and the C language lacks some basic ideas (such as packages) to support this (0.5)</p>
<p><strong>Aesthetics</strong>: C often verges towards unreadability and has lots of special characters with esoteric meaning (1.0)</p>
<h2 id="rust">Rust</h2>
<p><strong>Speed</strong>: Rust promises and mostly delivers C-like speed even beating C in a few <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html">benchmarks</a> (3.0)</p>
<p><strong>Conciseness</strong>: Rust has a lot of modern features that encourage conciseness including good lambdas and macros, but other features (for example <code>enum</code>s or deriving traits) seem to lead to a lot of code (2.0)</p>
<p><strong>Correctness</strong>: This is one of Rust's focus and selling points, only 'research' languages can compete here (3.0)</p>
<p><strong>Learnability</strong>: Rust should be easy to learn with its quite small feature set. Unfortunately the <code>trait</code> system is so different to other languages and the fact that most learns end up 'fighting with the borrow checker' really undermines this (1.0)</p>
<p><strong>Collaboration</strong>: Cargo is a great tool that makes working with Rust very easy and the access to any C library is a boon here (2.5)</p>
<p><strong>Aesthetics</strong>: A generally nice looking language with cool ideas but I do hate having to put <code>&amp;</code> or <code>.clone()</code> with (nearly) every function argument (2.0)</p>
<h2 id="python">Python</h2>
<p><strong>Speed</strong>: Python is an interpreted language so will never win this category. However Python is not even as fast as Javascript. Many Python libraries of course rely on calling C code, hence why Python is used in high-performance tasks such as deep learning, but saying that your language is fast because you can also use another language seems a self-defeating point (1.0)</p>
<p><strong>Conciseness</strong>: Python is easy and also very quick to write, with one of the most intuitive and compact lambda syntaxes (3.0)</p>
<p><strong>Correctness</strong>: Static checking is non-existent, there is a null type, exceptions are very haphazard and testing is not as easy as other languages (0.5)</p>
<p><strong>Learnability</strong>: When I said universities <em>used</em> to teach Java, that is because they have mostly moved to Python now (3.0)</p>
<p><strong>Collaboration</strong>: In theory, there is a package system and <code>pip</code> and <code>easy_install</code> make it easy to install packages... in theory. The practice is that often this can be quite a challenge (1.5)</p>
<p><strong>Aesthetics</strong>: I am personally indifferent to the curly-braces versus spacing argument, but Python is certainly what I would like a programming language to look like and it has plenty of cool 'pythonic' elements (3.0)</p>
<h2 id="scala">Scala</h2>
<p><strong>Speed</strong>: Mostly the same speed as Java but more classes mean that it is often a tad slower (2.0)</p>
<p><strong>Conciseness</strong>: Scala's many paradigms can effectively produce some very concise (if unreadable) code. More typical usage is still quite concise though (2.5)</p>
<p><strong>Correctness</strong>: Scala claims to have many of the tools that allow for correct programs although some of them (like null pointers) are optional and implementation can create errors at unexpected points (2.0)</p>
<p><strong>Learnability</strong>: Scala is not particularly easy-to-learn due to its many features but few of these features really provide any gotchas (1.5)</p>
<p><strong>Collaboration</strong>: Full compatibility with the JVM ecosystem is a great thing (3.0)</p>
<p><strong>Aesthetics</strong>: Lots of nice features and a reasonable syntax make Scala code quite beautiful and the language is full (maybe a bit too full) of cool features (2.0)</p>
<h2 id="kotlin-provisional">Kotlin (provisional)</h2>
<p><em>I don't have much experience with this language yet so scores will likely be revised</em></p>
<p><strong>Speed</strong>: It's a JVM language (2.0)</p>
<p><strong>Conciseness</strong>: One of the main objectives is to be a less-verbose Java, on this it mosty succeeds (2.0)</p>
<p><strong>Correctness</strong>: Acutally removing null pointers helps a lot here (2.0)</p>
<p><strong>Learnability</strong>: Very simple language with some nice tutorials (2.0)</p>
<p><strong>Collaboration</strong>: Again it is a JVM language (3.0)</p>
<p><strong>Aesthetics</strong>: Simple clean syntax (2.0)</p>
<h2 id="javascript">Javascript</h2>
<p><strong>Speed</strong>: Javascript has some very fast interpreters but they are still interpreters and don't really compete with compiled languages (1.5)</p>
<p><strong>Conciseness</strong>: As a scripting langauge Javascript is generally quite concise although some of the cascades of callbacks found in some APIs and ugly syntax for advanced features (e.g., classes) don't help (2.0)</p>
<p><strong>Correctness</strong>: Not really a feature of Javascript and one of the reasons why TypeScript was introduced (0.5)</p>
<p><strong>Learnability</strong>: Javascript is very easy to learn, but also quite full of 'gotcha' moments that cause more issue for new programmers than they should (2.0)</p>
<p><strong>Collaboration</strong>: Node came and introduced a proper package system to JS, but it seems to frequently not work or be hard to install (1.5)</p>
<p><strong>Aesthetics</strong>: A simple clean syntax without much to criticise (2.0)</p>
<h2 id="perl">Perl</h2>
<p><strong>Speed</strong>: Slow even for an interpreted language (0.5)</p>
<p><strong>Conciseness</strong>: Perl is the master of the one-liner, even if those one-liners may take hours to understand (3.0)</p>
<p><strong>Correctness</strong>: Perl has a strict mode (this better than Python) but still little in the way of safetry (1.0)</p>
<p><strong>Learnability</strong>: Although it is easy to get started, I have never felt I really mastered Perl. The joke about <code>perl &lt; /dev/random</code> compiling is valid here (2.0)</p>
<p><strong>Collaboration</strong>: PPM is one of the oldest and most creaking package management systems going (1.5)</p>
<p><strong>Aesthetics</strong>: Perl is really fugly but full of cool ideas (1.0)</p>
<h2 id="r">R</h2>
<p><strong>Speed</strong>: Sometimes you get it just right and the library functions work but otherwise R's performance is truly dreadful (0.5)</p>
<p><strong>Conciseness</strong>: For what R is designed for it does it concisely, for everything else it can be a nightmare (2.0)</p>
<p><strong>Correctness</strong>: As with most interpreted languages there are very few safety features (1.0)</p>
<p><strong>Learnability</strong>: Pretty okay (if you are also learning a stats course at the same time), but my experiences teaching it are that students find it hard (1.5)</p>
<p><strong>Collaboration</strong>: CRAN actually works pretty well (2.0)</p>
<p><strong>Aesthetics</strong>: Assignment with <code>&lt;-</code> is a very subjective thing (I hate it), there is some cool stuff here (1.5)</p>
<h2 id="c-1">C++</h2>
<p><strong>Speed</strong>: Technically you could just write C code and call it C++ and get the same performance. Even practically, the overheads of C++ constructs are pretty low (3.0)</p>
<p><strong>Conciseness</strong>: Extra headers full of duplicate functions and more boilerplate than C make this not a pleasant language to work with, even if a few modern features in C++11 do help a litle (1.0)</p>
<p><strong>Correctness</strong>: Much like with Scala, there are great features here but they can easily be ignored to ensure C compatibility (2.0)</p>
<p><strong>Learnability</strong>: This was the second language I learnt (after BASIC), but still learners struggle with this language a lot and the compiler produces error messages that look like they were written by eldritch beings from other dimensions (1.0)</p>
<p><strong>Collaboration</strong>: Lots of duplicate and incompatible systems here that fail to solve the problems with C (1.0)</p>
<p><strong>Aesthetics</strong>: C++ is definitely fugly and most of its cool ideas are very out-of-date now (1.0)</p>
<h2 id="overall">Overall</h2>
<table>
<thead>
<tr class="header">
<th>Language</th>
<th align="center">Speed</th>
<th align="center">Concise</th>
<th align="center">Correct</th>
<th align="center">Learn</th>
<th align="center">Collab</th>
<th align="center">Looks</th>
<th align="center">Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rust</td>
<td align="center">3.0</td>
<td align="center">2.0</td>
<td align="center">3.0</td>
<td align="center">1.0</td>
<td align="center">2.5</td>
<td align="center">2.0</td>
<td align="center">13.5</td>
</tr>
<tr class="even">
<td>Scala</td>
<td align="center">2.0</td>
<td align="center">2.5</td>
<td align="center">2.0</td>
<td align="center">1.5</td>
<td align="center">3.0</td>
<td align="center">2.0</td>
<td align="center">13.0</td>
</tr>
<tr class="odd">
<td>Kotlin</td>
<td align="center">2.0</td>
<td align="center">2.0</td>
<td align="center">2.0</td>
<td align="center">2.0</td>
<td align="center">3.0</td>
<td align="center">2.0</td>
<td align="center">13.0</td>
</tr>
<tr class="even">
<td>Python</td>
<td align="center">1.0</td>
<td align="center">3.0</td>
<td align="center">0.5</td>
<td align="center">3.0</td>
<td align="center">1.5</td>
<td align="center">3.0</td>
<td align="center">12.0</td>
</tr>
<tr class="odd">
<td>Java</td>
<td align="center">2.0</td>
<td align="center">1.0</td>
<td align="center">1.5</td>
<td align="center">2.5</td>
<td align="center">3.0</td>
<td align="center">1.5</td>
<td align="center">11.5</td>
</tr>
<tr class="even">
<td>Javascript</td>
<td align="center">1.5</td>
<td align="center">2.0</td>
<td align="center">0.5</td>
<td align="center">2.0</td>
<td align="center">1.5</td>
<td align="center">2.0</td>
<td align="center">9.5</td>
</tr>
<tr class="odd">
<td>C</td>
<td align="center">3.0</td>
<td align="center">1.5</td>
<td align="center">1.5</td>
<td align="center">2.0</td>
<td align="center">0.5</td>
<td align="center">1.0</td>
<td align="center">9.5</td>
</tr>
<tr class="even">
<td>C++</td>
<td align="center">3.0</td>
<td align="center">1.0</td>
<td align="center">2.0</td>
<td align="center">1.0</td>
<td align="center">1.0</td>
<td align="center">1.0</td>
<td align="center">9.0</td>
</tr>
<tr class="odd">
<td>R</td>
<td align="center">0.5</td>
<td align="center">2.0</td>
<td align="center">1.0</td>
<td align="center">1.5</td>
<td align="center">2.0</td>
<td align="center">1.5</td>
<td align="center">8.5</td>
</tr>
<tr class="even">
<td>Perl</td>
<td align="center">0.5</td>
<td align="center">3.0</td>
<td align="center">1.0</td>
<td align="center">2.0</td>
<td align="center">1.5</td>
<td align="center">1.0</td>
<td align="center">8.0</td>
</tr>
</tbody>
</table>
